sintaxis general del comando dd es:

# dd if=$input_data of=$output_data [options]

input_data y output_data pueden ser discos, particiones, archivos, dispositivosâ€¦ principalmente todo lo que usted pueda escribir a o leer de. 
se puede usar dd en un contexto de red para enviar flujos de datos a travÃ©s de su LAN, por ejemplo. 
se puede tener solamente la parte de entrada (input) en su comando dd, o solamente el comando de salida (output), y puede incluso eliminar ambos en algunos casos. 

Ejemplos:
dd if=/dev/urandom of=/dev/sda bs=4k -Â» Llena el disco con datos aleartorios

dd if=/dev/sda of=/dev/sdb bs=4096 -Â» DuplicaciÃ³n disco-a-disco

dd if=/dev/zero of=/dev/sda bs=4k -Â» Limpia un disco duro (puede necesitar ser repetido)

dd if=inputfile of=/dev/st0 bs=32k conv=sync -Â» Copia de archivo a dispositivo de cinta

dd if=/dev/st0 of=outfile bs=32k conv=sync -Â» El anterior, invertido

dd if=/dev/sda | hexdump -C | grep [^00] -Â» Verifica si el disco estÃ¡ realmente puesto a cero

dd if=/dev/urandom of=/home/$user/hugefile bs=4096 -Â» Llena una particiÃ³n (Â¡Cuidado con las particiones de sistema!)

dd if=/dev/urandom of=myfile bs=6703104 count=1 -Â» Codifica un archivo (tal vez antes de borrarlo)

dd if=/dev/sda3 of=/dev/sdb3 bs=4096 conv=notrunc,noerror -Â» Copia una particiÃ³n hacia otra particiÃ³n

dd if=/proc/filesystems | hexdump -C | less -Â» Visualiza los sistemas de ficheros disponibles

dd if=/proc/partitions | hexdump -C | less -Â» Visualiza las particiones disponibles en kb

dd if=/dev/sdb2 ibs=4096 | gzip > partition.image.gz conv=noerror -Â» Crea una imagen gzip de la segunda particiÃ³n del segundo disco

dd bs=10240 cbs=80 conv=ascii,unblock if=/dev/st0 of=ascii.out -Â» Copia el contenido de una cinta a un archivo, convirtiendo de EBCDIC a ASCII

dd if=/dev/st0 ibs=1024 obs=2048 of=/dev/st1 -Â» Copia de un dispositivo de bloques de 1KB a un dispositivo de bloques de 2KB

dd if=/dev/zero of=/dev/null bs=100M count=100
100+0 records in
100+0 records out
10485760000 bytes (10 GB) copied,

5.62955 s, 1.9 GB/s

Copia 10 GB de ceros a la papelera de reciclaje.

dd if=/dev/zero of=/dev/sda bs=512 count=2
fdisk -s /dev/sda
dd if=/dev/zero of=/dev/sda seek=(number_of_sectors â€“ 20) bs=1k

Borra GPT del disco. Como GPT escribe los datos al principio
Y al final del disco, despuÃ©s de borrar desde el principio, tenemos que encontrar el nÃºmero de sectores (el segundo comando), y entonces borrar los 20 Ãºltimos sectores.

dd if=/home/$user/bootimage.img of=/dev/sdc -Â» Crea un disco UDB booteable (mostrado aquÃ­ como /dev/sdc)

dd if=/dev/sda of=/dev/null bs=1m -Â» Una buena manera de buscar bloques malos. Relacionados con respaldos y sistemas

dd if=/dev/sda of=/dev/fd0 bs=512 count=1 -Â» Copia el MBR a un disco flexible

dd if=/dev/sda1 of=/dev/sdb1 bs=4096 -Â» DuplicaciÃ³n disco-a-disco

dd if=/dev/sr0 of=/home/$user/mycdimage.iso\ bs=2048 conv=nosync -Â» Crea una imagen de un CD

mount -o loop /home/$user/mycdimage.iso /mnt/cdimages/ -Â» Monta localmente la imagen mencionada

dd if=/dev/sda of=/dev/sdb bs=64k conv=sync -Â» Ãštil cuando se reemplaza un disco por otro de idÃ©ntico tamaÃ±o.

dd if=/dev/sda2 of=/home/$user/hddimage1.img bs=1M count=4430
dd if=/dev/sda2 of=/home/$user/hddimage2.img bs=1M count=8860
[â€¦]

Crea imÃ¡genes en DVD de una particiÃ³n (Ãºtil para hacer respaldos)

dd if=/$location/hddimage1.img of=/dev/sda2 bs=1M
dd if=/$location/hddimage2.img of=/dev/sda2 seek=4430 bs=1M
dd if=/$location/hddimage3.img of=/dev/sda2 seek=8860 bs=1M
[etcâ€¦]

Restaura del respaldo anterior

dd if=/dev/zero count=1 bs=1024 seek=1 of=/dev/sda6 -Â» Destruye el superbloque

dd if=/dev/zero count=1 bs=4096 seek=0 of=/dev/sda5 -Â» Otra forma de destruir el superbloque

dd if=/home/$user/suspicious.doc | clamscan -Â» Verifica el archivo en busca de virus (necesita ClamAV)

dd if=/home/$user/binary file | hexdump -C | less -Â» Ver el contenido de un archivo binario (necesita hexdump)

dd if=/home/$user/bigfile of=/dev/null
dd if=/dev/zero of=/home/$user/bigfile bs=1024 count=1000000

Realiza un benchmark de la velocidad de lectura/escritura del disco duro

dd if=/dev/sda of=/dev/sda -Â» Da nueva vida a viejos discos duros que no han sido usados por un tiempo (los discos deben estar â€œunmountedâ€)

dd if=/dev/mem | strings | grep â€˜string_to_searchâ€™ -Â» Examina el contenido de la memoria (legible para humanos, es decir)

dd if=/dev/fd0 of=/home/$user/floppy.image bs=2x80x18b conv=notrunc -Â» Copia un disco flexible

dd if=/proc/kcore | hexdump -C | less -Â» Muestra la memoria virtual

dd if=/proc/filesystems | hexdump -C | less -Â» Visualiza los sistemas de ficheros disponibles

dd if=/proc/kallsyms | hexdump -C | less -Â» Muestra los mÃ³dulos cargados

dd if=/proc/interrupts | hexdump -C | less -Â» Muestra la tabla de interrupciones

dd if=/proc/uptime | hexdump -C | less -Â» Muestra el tiempo de actividad en segundos

dd if=/proc/partitions | hexdump -C | less -Â» Visualiza las particiones disponibles en kb

dd if=/proc/meminfo | hexdump -C | less -Â» Muestra el estado de la memoria

dd if=/dev/urandom of=/home/$user/myrandom bs=100 count=1 -Â» Crea un archivo de 1kb de jerigonza aleatoria

dd if=/dev/mem of=/home/$user/mem.bin bs=1024 -Â» Crea una imagen del estado actual de la memoria del sistema

dd if=/home/$user/myfile -Â» Imprime el archivo a stdout

dd if=/dev/sda2 bs=16065 | hexdump -C | grep â€˜text_to_searchâ€™ -Â» Busca una cadena en una particiÃ³n entera; incluso si estÃ¡ asegurada, usted puede bootear un liveCD

dd if=/home/$user/file.bin skip=64k bs=1 of=/home/$user/convfile.bin -Â» Copia file.bin a convfile.bin saltÃ¡ndose los primeros 64 kb

dd if=/home/$user/bootimage.img of=/dev/sdc -Â» Crea un disco UDB booteable (mostrado aquÃ­ como /dev/sdc)

dd if=/dev/mem bs=1k skip=768 count=256 2>/dev/null | strings -n 8 -Â» Lee la BIOS.

dd bs=1k if=imagefile.nrg of=imagefile.iso skip=300k -Â» Convierte una imagen de Nero en una imagen ISO estÃ¡ndar.
Esto es posible porque la Ãºnica diferencia entre las dos son los 300 kB de encabezamiento que Nero adiciona a una imagen ISO estÃ¡ndar.

echo -n â€œhello vertical worldâ€ | dd cbs=1 conv=unblock 2> /dev/null -Â» IntÃ©ntalo, es seguro. ðŸ™‚

dd if=/dev/sda1 | gzip -c | split -b 2000m â€“ \ /mnt/hdc1/backup.img.gz -Â» Crea una imagen gzip de una particiÃ³n utilizando divisiÃ³n

cat /mnt/hdc1/backup.img.gz.* | gzip -dc | dd of=/dev/sda1 -Â» Restaura el respaldo anterior

dd if=/dev/zero of=myimage bs=1024 count=10240 -Â» Crea una imagen vacÃ­a del disco

dd ibs=10 skip=1 -Â» Divide los primeros 10 bytes de stdin

dd bs=265b conv=noerror if=/dev/st0 of=/tmp/bad.tape.image -Â» Hace una imagen de una cinta con sitios malos

dd if=/dev/sda count=1 | hexdump -C -Â» Visualiza su MBR

dd if=/dev/sda | nc -l 10001 nc $system_to_backup_IP 10001 | dd of=sysbackupsda.img -Â» Respaldo rÃ¡pido de la red usando netcat

dd if=/dev/zero of=/dev/sdX bs=1024000 count=1 -Â» Limpia los primeros 10MB de la particiÃ³n

dd if=/dev/zero of=tmpswap bs=1k
count=1000000
chmod 600 tmpswap
mkswap tmpswap
swapon tmpswap

Crea un espacio temporal de intercambio

dd if=/dev/sda of=/dev/null bs=1024k count=1024
1073741824 bytes (1.1 GB) copied,
24.1684 s, 44.4 MB/s

Determina la velocidad secuencial de I/O de su disco.

dd if=/dev/random count=1 2>/dev/null | od -t u1 |\ awk â€˜{ print $2}â€™ | head -1 -Â» Genera un nÃºmero aleatorio

dd if=/dev/mem of=myRAM bs=1024 -Â» Copia la memoria RAM hacia un archivo

dd if=/dev/sda bs=512 count=1 | od -xa -Â» Ver el contenido de su MBR en formato hex y ASCII

dd if=/my/old/mbr of=/dev/sda bs=446 count=1 -Â» Restaura el MBR sin alterar el registro de la tabla de particiÃ³n el cual estÃ¡ entre 447 â€“ 511 bytes

dd if=/dev/sda1 | split -b 700m â€“ sda1-image -Â» Crea una copia de la particiÃ³n y salva imÃ¡genes donde el tamaÃ±o mÃ¡ximo del volumen es 700MB

ls -l | dd conv=ucase -Â» Convierte la salida de un comando en mayÃºsculas

echo â€œMY UPPER CASE TEXTâ€ | dd conv=lcase -Â» Convierte cualquier texto a minÃºsculas

dd if=/etc/passwd cbs=132 conv=ebcdic of=/tmp/passwd.ebcdic -Â» Convierte el archivo de contraseÃ±as del sistema a un archivo de longitud fija de formato EBCDIC

dd if=text.ascii of=text.ebcdic conv=ebcdic -Â» Convierte de ASCII a EBCDIC

dd if=myfile of=myfile conv=ucase -Â» Convierte un archivo a mayÃºsculas (simple SED o reemplazo tr)



Apuntes

UGOA
U: User
G: Group
O: Others
A: All

"chmod +x archivo01.txt" > Agrega X (ejecutable) a todos los permisos

"chmod -R archivo01.txt" > Le saca el R (permiso de lectura) a todos los permisos

"chmod u=-x, rw archivo01.txt" saca la x (ejecutable) a los permisos del usuario

"chmod u=-x+rw archivo01.txt" saca la x (ejecutable) a los permisos del usuario

"chown" Cambia el nombre del usuario obligatoriamente, y opcionalmente del grupo
"chown Alumnos archivo01.txt" > cambia el nombre del dueÃ±o a Alumnos
"chown alumnos:users archivo01.txt" > dueÃ±o = Alumnos, Grupo = Users
"chgrp users archivo01.txt" > cambia el nombre del grupo a Users
"chgrp" Cambia obligatoriamente el nombre del grupo

"ls -l" > visualiza todo lo que estÃ¨ dentro del DIR donde estoy parados

chown nobody:users Carpeta

chgrp nogroup Carpeta

"MORE /ETC/PASSWD" > INFO DE LOS USUARIOS CREADOS 
"GREP MARCOS /ETC/PASSWD" > BUSCA EL USUARIO MARCOS

"useradd" 
"-m" > crea el directorio 
"-c" > comentario de un usuario 
"-s" > shell que va a usar
"-g" > grupo principal
useradd -m -c "Usuario de Prueba" -s /bin/rbash prueba2

rbash > Shell cortado o Enjaulado

"passwd prueba2" > le agrega una contraseÃ±a a prueba2
"grep prueba2 /etc/shadow" > me muestra el mÃ¨todo, el salto y la password de prueba2

"login" > loguea, pide user y password

miÃ©rcoles, 19 de junio de 2019
3 Particiones Primarias + 1(Cuarta) con lo que sobra y de ahÃ¬ se generan lÃ²gicas
4 particiones en total hasta 16

3 primarias (Datos de SO, etc)
1 extendidas (Datos que sobran de las primarias)
12 logicas (uso de datos a partir de la extendida)

fdisk -l /dev/sdb

fdisk /dev/sdb 
p > primario

lvm
pvcreate /dev(sdb1 /dev/sdc1 > crea el volumen fisico
pvs > muestra los datos de los volumenes fisicos
pvremove /dev/sdb1 > remueve un volumen fisico
vgcreate vg00 /dev/sdb1 > crea nombre del volumen a la particiÃ²n asignada
vgs > muestra datos del volumen logico
vgextend vg00 /dev/sdc1 > extiende el volumen de sdc1 a vg00 (sdb1) 
vgreduce vg00 /dev/sdc1 > quita la particion sdc1 de la extencion vg00 (Pasa la informacion a uno de los discos que queda en la extencion)

lsblk > arbol de discos y particiones
lvcreate -L +30MB -n rrhh vg00 > crea el volumen logico "rrhh" de 30mb en vg00
lvs > muestra el volumen logico
lvextend -L +20MB /dev/vg00/cont > extiende cont de vg00 en 20mbs
mkfs.ext4 /dev/vg00/cont > formatea el file system de la particion
mkdir /rrh /cont > crea los directorios 
mount /dev/vg00/rrhh /rrhh > monta el directorio rrhh
mount /dev/vg00/cont /cont > monta el directorio cont

lsblk > muestra particiones y puntos de montaje

chown: grupo

-m para crear directorio
-s para crear el shell

IF [ -z /etc/passwd ]; then
echo "- si esta vacio"
else
echo "- no esta vacio" 
fi

RMDIR -P > Elimina directorios vacÃ­os y el parent

Clear / Ctrl+L > limpia la pantalla

Grep(BÃºsqueda)
Egrep(BÃºsqueda Extendida)

grep -i 'Root' Archivo.txt > busca en archivo.txt la palabra Root, el -i ignora mayusculas y minusculas

grep '^$' /etc/passwd -> obtiene las lineas en blanco en la ruta donde se almacenan los usuarios

grep -o 'RoOt' -> Busca la coincidencia exacta en la palabra

grep '^ Hola' -> Busca Hola al principio de la oraciÃ³n

grep 'Hola $' -> Busca Hola al final de la oraciÃ³n

grep ^[a-z][A-Z][0-9] -> busca la combinaciÃ³n de una letra de la a a la z en minuscula, seguida de una letra de la a a la z en mayusculas y luego un numero entre el 0 y el 9. Ejemplo "aT9"

grep [^a-z] -> busca que no empiece con minuscula

grep [0-9]{4} \- [0-9]{4} -> busca cuatro nÃºmeros seguidos por un guiÃ³n, y luego cuatro nÃºmeros mÃ¡s. Ejemplo: NÃºmero telefÃ³nico "1234-9876"

grep [0-9]{1,4} -> busca de uno a cuatro nÃºmeros consecutivos.

grep [a-zA-Z0-9._-]*\@ [a-zA-Z0-9._-]*\.[a-zA-Z]{2,3} -> busca un mail

Comando SED (bÃºsqueda y modificaciÃ³n)

sed 's/Root/ROOT/' archivo1.txt -> cambia la palabra Root a ROOT en archivo1.txt

sed 's/Root/ROOT/G archivo2.txt -> otorga permiso global al archivo2.txt

USERADD user1 -> crea grupo y usuario con el nombre user1

USERDEL userx -> elimina el userx

GROUPADD grupo2 -> crea el grupo "grupo2"

ADDUSER user9 -> crea el usuario "user9" sin generarle un grupo

ADDUSER -g Alumnos Pipo -> crea el usuario "Pipo" en el grupo "Alumnos"

USERMOD -G "Profesores" "Pipo" -> Mueve al usuario "Pipo" al grupo "Profesores"

Particiones de Disco:

FDISK /DEV/SDB
N
P
1/2
ENTER
+30MB

PVCREATE /DEV/SDB








